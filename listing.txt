
/* File src/EnergyBus.h */

#ifndef ENERGY_BUS_INCLUDED
#define ENERGY_BUS_INCLUDED

#include <iostream>
#include <vector>
#include <map>

using namespace std;

class EnergyBus
{
private:
    int no, code;
    double angle, minAngle, maxAngle;
    double voltage, minVoltage, maxVoltage;
    double activePowerLoad, reactivePowerLoad;
    double reactivePowerGen, minReactivePowerGen, maxReactivePowerGen;
    double activePowerGen, minActivePowerGen, maxActivePowerGen;
    double G, B;
    vector <double*> costCoefficents;
    vector <EnergyBus*> links;

public:
    EnergyBus(int, int);

    int getNo();

    double cost();

    double getVoltage();

    EnergyBus * setVoltage(double value);

    EnergyBus * setVoltage(double value, double minV, double maxV);

    double getAngle();

    EnergyBus * setAngle(double value);

    EnergyBus * setAngle(double value, double minA, double maxA);

    double getActivePowerGen();

    EnergyBus * setActivePowerGen(double value);

    double getActivePowerLoad();

    EnergyBus * setActivePowerLoad(double);

    double getReactivePowerGen();

    EnergyBus * setReactivePowerGen(double);

    double getReactivePowerLoad();

    EnergyBus * setReactivePowerLoad(double);

    double * getPowerGenLimits();

    EnergyBus * setPowerGenLimits(double minP, double maxP, double minQ, double maxQ);

    EnergyBus * setCostPart(double minP, double maxP, float A, float B, float C);

    EnergyBus * addLinkedBus(EnergyBus *, double, double);

    vector <EnergyBus*> getLinkedBus();

    double getG();

    double getB();

    bool isGeneratorBus();

    bool isBalancedBus();

    bool checkRestractions();

    void display();
};

#endif
/* File src/EnergyBusSet.h */

#ifndef ENERGY_BUS_SET_INCLUDED
#define ENERGY_BUS_SET_INCLUDED

#include <map>
#include "EnergyBus.h"

using namespace std;

class EnergyBusSet
{
private:
    map <int, EnergyBus *> buses;
    map <int, EnergyBus *>::iterator it;
public:
    EnergyBusSet();

    EnergyBus* getBus(int);

    EnergyBusSet* addBus(EnergyBus *);

    double cost();

    double getActivePowerLoad();

    double getReactivePowerLoad();

    double getActivePowerGen();

    double getReactivePowerGen();

    int size();

    bool checkRestractions();

    EnergyBus* operator [](int);
};

#endif
/* File src/Energy.h */

#ifndef ENERGY_INCLUDED
#define ENERGY_INCLUDED

#include <vector>
#include <math.h>
#include <ctime>
#include <string>

#include "ga/ga.h"
#include "ga/GARealGenome.h"
#include "tinyxml/tinyxml.h"

#include "EnergyBus.h"
#include "EnergyBusSet.h"
#include "EnergyLine.h"
#include "EnergyLineSet.h"
#include "Newton.h"

using namespace std;

class Energy
{
private:
    Energy();
    Energy(Energy &);
    static Energy * instance;

    float objective(GAGenome &);
    double getYCell(int, int, vector <double>);
    double getFCell(int, vector <double>);

    void clearData();
    void parseData();
    void parseBusData();
    void parseLinesData();
    void parseGAparams();
    void calculate();
    void fillFromGenome(GARealGenome);

    string inputDir, outputDir;
    EnergyBus * balanceBus;
    EnergyLineSet lines;
    EnergyBusSet allBus;
    EnergyBusSet genBus;
    EnergyBusSet notGenBus;
    EnergyBusSet genWithoutBalanceBus;
    GAParameterList params;

    clock_t t1, t2;
public:
    static Energy * getInstance();

    static float wrap_objective(GAGenome &);
    static double wrap_getYCell(int, int, vector <double>);
    static double wrap_getFCell(int, vector <double>);

    void setup(string, string);
    void display();
    void progress(float);
    void report();
    void solve();
};

#endif
/* File src/EnergyLine.h */

#ifndef ENERGY_LINE_INCLUDED
#define ENERGY_LINE_INCLUDED

#include <iostream>
#include <vector>
#include <map>
#include <math.h>
#include "EnergyBus.h"

using namespace std;

class EnergyLine
{
private:
    EnergyBus * from;
    EnergyBus * to;
    float R, X;
    double G, B;
public:
    EnergyLine(EnergyBus *, EnergyBus *, double, double);

    double getR();

    double getX();

    double getG();

    double getB();

    double getActivePower();

    double getReactivePower();

    EnergyBus * getFrom();

    EnergyBus * getTo();

    void display();
};

#endif
/* File src/EnergyLineSet.h */

#ifndef ENERGY_LINE_SET_INCLUDED
#define ENERGY_LINE_SET_INCLUDED

#include <vector>
#include <map>
#include "EnergyLine.h"

using namespace std;

class EnergyLineSet
{
private:
    map <int, EnergyLine *> lines;
    map <int, vector <EnergyLine*> > links;
    map <int, EnergyLine *>::iterator it;
public:
    EnergyLineSet();

    EnergyLineSet * addLine(EnergyLine *);

    EnergyLine * getLine(int, int);

    int size();

    double getActivePower();

    double getReactivePower();

    vector <EnergyLine*> getBusLines(int busNo);

    EnergyLine* operator [](int n);
};

#endif
/* File src/Gauss.h */

#ifndef GAUSS_INCLUDED
#define GAUSS_INCLUDED

#include <cmath>
#include <vector>

using namespace std;

/**
 * Функция решения линейной системы уравнений
 */
int gauss (vector < vector<double> >, vector <double>, vector <double> &);

#endif
/* File src/Newton.h */

#ifndef NEWTON_INCLUDED
#define NEWTON_INCLUDED

#include <cmath>
#include <vector>
#include "Gauss.h"

using namespace std;

/**
 * Класс для решения нелинейных систем уравнений
 */
class Newton
{
private:
    double EPS;
    bool DEBUG;
    int MAX_STEPS, N;
    vector <double> X, Z, F;
    vector < vector <double> > Y;
    vector <vector <double> > getY();
    double (*getYCell)(int, int, vector <double>);
    vector <double> getF();
    double (*getFCell)(int, vector <double>);
    double getEPS();
public:
    Newton(
            double (*)(int, vector <double>),
            double (*)(int, int, vector <double>),
            double,
            int,
            bool
    );
    int solve (vector <double> &);
};

#endif
/* File src/EnergyBus.cpp */

#include "EnergyBus.h"

using namespace std;

EnergyBus::EnergyBus(int n, int c)
{
    no = n;
    code = c;
    angle = minAngle = maxAngle = 0;
    voltage = minVoltage = maxVoltage =  0;
    activePowerLoad = reactivePowerLoad = 0;
    reactivePowerGen = minReactivePowerGen = maxReactivePowerGen = 0;
    activePowerGen = minActivePowerGen = maxActivePowerGen = 0;
    G = B = 0;
}

int EnergyBus::getNo()
{
    return no;
}

double EnergyBus::cost()
{
    double ret = 0;

    if (this->isGeneratorBus())
    {
        double coefA = (*costCoefficents.begin())[2],
               coefB = (*costCoefficents.begin())[3],
               coefC = (*costCoefficents.begin())[4];

        for (vector <double *>::iterator it = costCoefficents.begin(); it != costCoefficents.end(); ++it)
        {
            if (activePowerGen > (*it)[0] && activePowerGen <= (*it)[1]) {
                coefA = (*it)[2];
                coefB = (*it)[3];
                coefC = (*it)[4];
                break;
            }
        }

        ret = coefA * activePowerGen * activePowerGen + coefB * activePowerGen + coefC;
    }

    return ret;
}

double EnergyBus::getVoltage()
{
    return voltage;
}

EnergyBus * EnergyBus::setVoltage(double value)
{
    voltage = value;
    return this;
}

EnergyBus * EnergyBus::setVoltage(double value, double minV, double maxV)
{
    voltage = value;
    minVoltage = minV;
    maxVoltage = maxV;
    return this;
}

double EnergyBus::getAngle()
{
    return angle;
}

EnergyBus * EnergyBus::setAngle(double value)
{
    angle = value;
    return this;
}

EnergyBus * EnergyBus::setAngle(double value, double minA, double maxA)
{
    angle = value;
    minAngle = minA;
    maxAngle = maxA;
    return this;
}

double EnergyBus::getActivePowerGen()
{
    return activePowerGen;
}

EnergyBus * EnergyBus::setActivePowerGen(double value)
{
    activePowerGen = value;
    return this;
}

double EnergyBus::getActivePowerLoad()
{
    return activePowerLoad;
}

EnergyBus * EnergyBus::setActivePowerLoad(double value)
{
    activePowerLoad = value;
    return this;
}

double EnergyBus::getReactivePowerGen()
{
    return reactivePowerGen;
}

EnergyBus * EnergyBus::setReactivePowerGen(double value)
{
    reactivePowerGen = value;
    return this;
}

double EnergyBus::getReactivePowerLoad()
{
    return reactivePowerLoad;
}

EnergyBus * EnergyBus::setReactivePowerLoad(double value)
{
    reactivePowerLoad = value;
    return this;
}

double * EnergyBus::getPowerGenLimits()
{
    double * ret = new double[4];
    ret[0] = minActivePowerGen;
    ret[1] = maxActivePowerGen;
    ret[2] = minReactivePowerGen;
    ret[3] = maxReactivePowerGen;
    return ret;
}

EnergyBus * EnergyBus::setPowerGenLimits(double minP, double maxP, double minQ, double maxQ)
{
    minActivePowerGen = minP;
    maxActivePowerGen = maxP;
    minReactivePowerGen = minQ;
    maxReactivePowerGen = maxQ;
    return this;
}

EnergyBus * EnergyBus::setCostPart(double minP, double maxP, float A, float B, float C)
{
    double * part = new double[5];
    part[0] = minP; part[1] = maxP;
    part[2] = A; part[3] = B; part[4] = C;
    costCoefficents.push_back(part);
    return this;
}

EnergyBus * EnergyBus::addLinkedBus(EnergyBus * bus, double g, double b)
{
    links.push_back(bus);
    G += g;
    B += b;
    return this;
}

vector <EnergyBus*> EnergyBus::getLinkedBus()
{
    return links;
}

double EnergyBus::getG()
{
    return -G;
}

double EnergyBus::getB()
{
    return -B;
}

bool EnergyBus::isGeneratorBus()
{
    return code == 1 || code == 2;
}

bool EnergyBus::isBalancedBus()
{
    return code == 1;
}

bool EnergyBus::checkRestractions()
{
    return activePowerGen <= maxActivePowerGen && activePowerGen >= minActivePowerGen
//        && reactivePowerGen <= maxReactivePowerGen && reactivePowerGen >= minReactivePowerGen
        && voltage <= maxVoltage && voltage >= minVoltage
        && angle <= maxAngle && angle >= minAngle;
}

void EnergyBus::display()
{
    cout << endl << "*** Узел №" << no << " *** "
        << "G=" << getG() << "; B=" << getB()
        << "; V=" << voltage << "; Angle=" << angle
        << "; Pload=" << activePowerLoad << "; Qload=" << reactivePowerLoad;

    if (isGeneratorBus())
    {
        cout << "; Pgen=" << activePowerGen << "; Qgen=" << reactivePowerGen
            << "; cost=" << cost();
    }

    cout << "; restractions=" << checkRestractions();
}
/* File src/EnergyBusSet.cpp */

#include "EnergyBusSet.h"

EnergyBusSet::EnergyBusSet()
{

}

EnergyBus* EnergyBusSet::getBus(int n)
{
    return buses[n];
}

EnergyBusSet* EnergyBusSet::addBus(EnergyBus * bus)
{
    buses[bus->getNo()] = bus;
    return this;
}

double EnergyBusSet::cost()
{
    double ret = 0;

    for (it = buses.begin(); it != buses.end(); ++it)
    {
        ret += it->second->cost();
    }

    return ret;
}

double EnergyBusSet::getActivePowerLoad()
{
    double ret = 0;

    for (it = buses.begin(); it != buses.end(); ++it)
    {
        ret += it->second->getActivePowerLoad();
    }

    return ret;
}

double EnergyBusSet::getReactivePowerLoad()
{
    double ret = 0;

    for (it = buses.begin(); it != buses.end(); ++it)
    {
        ret += it->second->getReactivePowerLoad();
    }

    return ret;
}

double EnergyBusSet::getActivePowerGen()
{
    double ret = 0;

    for (it = buses.begin(); it != buses.end(); ++it)
    {
        ret += it->second->getActivePowerGen();
    }

    return ret;
}

double EnergyBusSet::getReactivePowerGen()
{
    double ret = 0;

    for (it = buses.begin(); it != buses.end(); ++it)
    {
        ret += it->second->getReactivePowerGen();
    }

    return ret;
}

int EnergyBusSet::size()
{
    return buses.size();
}

bool EnergyBusSet::checkRestractions()
{
    bool ret = true;

    for (it = buses.begin(); it != buses.end(); ++it)
    {
        if ( ! it->second->checkRestractions())
        {
            ret = false;
            break;
        }
    }

    return ret;
}

EnergyBus* EnergyBusSet::operator [](int n)
{
    it = buses.begin();
    for (int i = 0; i < n; ++i, ++it);
    return it->second;
}
/* File src/Energy.cpp */

#include <iostream>

#define INSTANTIATE_REAL_GENOME
#include "Energy.h"

using namespace std;

const long double PI = 2 * asin(1);

Energy * Energy::instance = NULL;

Energy::Energy()
{

}

Energy::Energy(Energy& clone)
{

}

Energy * Energy::getInstance()
{
    if ( ! instance)
    {
        instance = new Energy();
    }

    return instance;
}

void Energy::clearData()
{

}

void Energy::setup(string input, string output)
{
    inputDir = input;
    outputDir = output;
    clearData();
    parseData();
}

void Energy::solve()
{
    GARealAlleleSetArray alleles;
    for (int i = 0, size = genBus.size(); i < size; ++i)
    {
        EnergyBus * bus = genBus[i];
        if (bus->isBalancedBus())
        {
            continue;
        }
        double * powerLimits = bus->getPowerGenLimits();
        alleles.add(powerLimits[0], powerLimits[1], GAAllele::INCLUSIVE, GAAllele::INCLUSIVE);
    }

    GARealGenome genome(alleles, Energy::wrap_objective);
    genome.crossover(GARealGenome::OnePointCrossover);
    GASteadyStateGA ga(genome);
    ga.parameters(params);
    // @todo можно здесь подумать
    GANoScaling scaling;
    ga.scaling(scaling);
    GATournamentSelector selector;
    ga.selector(selector);

    progress(0);
    t1 = clock();
    ga.evolve();
    t2 = clock();

    genome = ga.statistics().bestIndividual();
    fillFromGenome(genome);
    calculate();
    display();
    report();
}

int i = 0;

float Energy::objective(GAGenome & g)
{
    int number_of_generations = *(int *)(params(gaNnGenerations)->value());
    int population_size = *(int *)(params(gaNpopulationSize)->value());
    progress((double)(++i * 200)/(population_size * number_of_generations));
    float ret = 0.0;
    GARealGenome& genome = (GARealGenome&) g;

    fillFromGenome(genome);
    calculate();

    double cost = allBus.cost();

    // @todo, можно от этого шага избивиться
    if ( ! allBus.checkRestractions())
    {
        cost += 1000;
    }

    ret = 1 / cost;

    return ret;
}

void Energy::calculate()
{
    vector <double> x;
    int n = allBus.size();
    // начальные значения
    for (int i = 0; i < n * 2; ++i) {
        x.push_back(i < n ? 0 : 1);
    }

    int solve = 0;
    Newton newton(Energy::wrap_getFCell, Energy::wrap_getYCell, 10e-3, 10, false);

    solve = newton.solve(x);

    if (solve > 0)
    {
        for (int i = 0; i < n; ++i) {
            EnergyBus* bus = allBus[i];

            bus->setAngle(x[i])->setVoltage(x[n + i]);
        }

        // Расчёт реактивной мощности
        for (int i = 0, size = genWithoutBalanceBus.size(); i < size; ++i)
        {
            EnergyBus* kBus = genWithoutBalanceBus[i];
            double ret = 0.0;
            double Vk = kBus->getVoltage();
            double Dk = kBus->getAngle();
            double Bkk = kBus->getB();
            vector <EnergyLine*> busLines = lines.getBusLines(kBus->getNo());

            ret += kBus->getReactivePowerLoad()/100 - Vk * Vk * Bkk;

            for (vector <EnergyLine*>::iterator it = busLines.begin(); it != busLines.end(); ++it)
            {
                EnergyLine* line = *it;
                EnergyBus* from = line->getFrom();
                EnergyBus* to = line->getTo();
                double Bkm = line->getB();
                double Gkm = line->getG();
                double Dm, Vm;

                if (to == kBus)
                {
                    to = from;
                }

                Dm = to->getAngle();
                Vm = to->getVoltage();

                ret -= Vk * Vm * (Bkm * cos(Dk - Dm) - Gkm * sin(Dk - Dm));
            }

            kBus->setReactivePowerGen(ret * 100);
        }
    }


    double activePower = allBus.getActivePowerLoad() + lines.getActivePower() - genWithoutBalanceBus.getActivePowerGen();
    double reactivePower = allBus.getReactivePowerLoad() + lines.getReactivePower() - genWithoutBalanceBus.getReactivePowerGen();
    activePower < 0 && (activePower = 0);
    balanceBus->setActivePowerGen(activePower)
            ->setReactivePowerGen(reactivePower);
}

void Energy::fillFromGenome(GARealGenome genome)
{
    for (int i = 0, size = genWithoutBalanceBus.size(); i < size; ++i)
    {
        EnergyBus* bus = genWithoutBalanceBus[i];
        bus->setActivePowerGen(genome.gene(i));
    }
}

double Energy::getFCell(int i, vector <double> x)
{
    double ret = 0;

    int n = allBus.size();
    int k = i % n;
    EnergyBus* kBus = allBus[k];
    bool isForP = i < n;

    double Vk = x[k + n];
    double Pk = (-kBus->getActivePowerLoad()) / 100;
    double Qk = kBus->getReactivePowerLoad() / 100;
    double Gkk = kBus->getG();
    double Bkk = kBus->getB();
    double Dk = x[k];

    if (kBus->isGeneratorBus())
    {
        Pk += kBus->getActivePowerGen() / 100;
    }

//  cout << endl << "DEBUG: j=" << j
//          << ", kNodeNumber=" << bus->getNo()
//          << endl
//          << ", isForP=" << isForP
//          << ", Vk=" << Vk
//          << endl
//          << ", Dk=" << Dk
//          << ", Gkk=" << Gkk << ", Bkk=" << Bkk
//          << endl;

    if (kBus->isBalancedBus())
    {
        if (isForP)
        {
            ret = Dk;
        }
        else
        {
            ret = Vk - kBus->getVoltage();
        }
    }
    else if (kBus->isGeneratorBus() && ! isForP)
    {
        ret = Vk - kBus->getVoltage();
    }
    else
    {
        if (isForP)
        {
            ret += Pk - Vk * Vk * Gkk;
        }
        else
        {
            ret += Qk + Vk * Vk * Bkk;
        }

        vector <EnergyLine*> busLines = lines.getBusLines(kBus->getNo());
        for (vector <EnergyLine*>::iterator it = busLines.begin(); it != busLines.end(); ++it)
        {
            EnergyLine * line = *it;
            EnergyBus * from = line->getFrom();
            EnergyBus * to = line->getTo();
            double Bkm = line->getB();
            double Gkm = line->getG();
            double Dm, Vm;

            if (to == kBus)
            {
                to = from;
            }
            Dm = x[to->getNo() - 1]; // @todo;
            Vm = x[n + to->getNo() -1];

            if (isForP)
            {
                ret -= Vk * Vm * (Gkm * cos(Dk - Dm) + Bkm * sin(Dk - Dm));
            }
            else
            {
                ret += Vk * Vm * (Bkm * cos(Dk - Dm) - Gkm * sin(Dk - Dm));
            }
        }
    }

    return ret;
}

double Energy::getYCell(int i, int j, vector <double> x)
{
    double ret = 0;

    int n = allBus.size();
    int k = i % n;
    int m = j % n;
    EnergyBus* kBus = allBus[k];
    EnergyBus* mBus = allBus[m];
    EnergyLine* kmLine = lines.getLine(kBus->getNo(), mBus->getNo());

    bool isForP = i < n;
    bool isDelta = j < n;
    double Vk = x[k + n];
    double Vm = x[m + n];
    double Dk = x[k];
    double Dm = x[m];
    double Bkk = kBus->getB();
    double Gkk = kBus->getG();
    double Bkm = kmLine ? kmLine->getB() : 0;
    double Gkm = kmLine ? kmLine->getG() : 0;

//  cout << endl << "DEBUG: i=" << i << ", j=" << j
//          << ", kNodeNumber=" << kBus->getNo()
//          << ", mNodeNumber=" << mBus->getNo()
//          << endl
//          << ", isGen=" << kBus->isGeneratorBus()
//          << ", isForP=" << isForP
//          << ", isDelta=" << isDelta
//          << ", Vk=" << Vk
//          << ", Vm=" << Vm
//          << endl
//          << ", Dk=" << Dk
//          << ", Dm=" << Dm
//          << ", Gkm=" << Gkm << ", Bkm=" << Bkm
//          << ", Gkk=" << Gkk << ", Bkk=" << Bkk
//          << endl;

    if (kBus->isBalancedBus())
    {
        if (i == j)
        {
            ret = 1;
        }
        else
        {
            ret = 0;
        }

        return ret;
    }
    else if (kBus->isGeneratorBus() && ! isForP)
    {
        if (i == j)
        {
            ret = 1;
        }
        else
        {
            ret = 0;
        }

        return ret;
    }

    if (kBus == mBus)
    {
        if ( ! isDelta)
        {
            if (isForP)
            {
                ret -= 2 * Vk * Gkk;
            }
            else
            {
                ret += 2 * Vk * Bkk;
            }
        }

        vector <EnergyLine*> busLines = lines.getBusLines(kBus->getNo());

        for (vector <EnergyLine*>::iterator it = busLines.begin(); it != busLines.end(); ++it)
        {
            EnergyLine* line = *it;
            EnergyBus* from = line->getFrom();
            EnergyBus* to = line->getTo();
            double Bkm = line->getB();
            double Gkm = line->getG();
            double Dm, Vm;

            if (to == kBus)
            {
                to = from;
            }

            Dm = x[to->getNo() - 1]; // @todo;
            Vm = x[n + to->getNo() -1];

            if (isForP)
            {
                if (isDelta)
                {
                    ret += Vk * Vm * (Gkm * sin(Dk - Dm) - Bkm * cos(Dk - Dm));
                }
                else
                {
                    ret -= Vm * (Gkm * cos(Dk - Dm) + Bkm * sin(Dk - Dm));
                }
            }
            else
            {
                if (isDelta)
                {
                    ret -= Vk * Vm * (Bkm * sin(Dk - Dm) + Gkm * cos(Dk - Dm));
                }
                else
                {
                    ret += Vm * (Bkm * cos(Dk - Dm) - Gkm * sin(Dk - Dm));
                }
            }
        }
    }
    else
    {
        if (isForP)
        {
            if (isDelta)
            {
                ret = Vk * Vm
                        * (-Gkm * sin(Dk - Dm) + Bkm * cos(Dk - Dm));
            }
            else
            {
                ret = -Vk
                        * (Gkm * cos(Dk - Dm) + Bkm * sin(Dk - Dm));
            }
        }
        else
        {
            if (isDelta)
            {
                ret = Vk * Vm
                        * (Bkm * sin(Dk - Dm) + Gkm * cos(Dk - Dm));
            }
            else
            {
                ret = Vk
                        * (Bkm * cos(Dk - Dm) - Gkm * sin(Dk - Dm));
            }
        }
    }

    return ret;
}

void Energy::display()
{
    cout << endl << "*** Исходные данные ***";
    cout << endl << "Генераторные узлы: ";
    for (int i = 0, size = genBus.size(); i < size; ++i)
    {
        cout << genBus[i]->getNo() << " ";
    }

    cout << endl << "Нагрузочные узлы: ";
    for (int i = 0, size = notGenBus.size(); i < size; ++i)
    {
        cout << notGenBus[i]->getNo() << " ";
    }

    cout << endl << "Балансирующий узел: " << balanceBus->getNo();

    cout << endl << endl << "*** Результаты ***";

    cout << endl << "Линии и их характеристики: ";
    for (int i = 0, size = lines.size(); i < size; ++i)
    {
        lines[i]->display();
    }

    cout << endl << "Узлы и их характеристики: ";
    for (int i = 0, size = allBus.size(); i < size; ++i)
    {
        allBus[i]->display();
    }

    cout << endl << "Нужная активная мощность: " << allBus.getActivePowerLoad() << " МВт";
    cout << endl << "Нужная реактивная мощность: " << allBus.getReactivePowerLoad() << " МВт";
    cout << endl << "Получившаяся активная мощность: " << allBus.getActivePowerGen() << " МВт";
    cout << endl << "Получившаяся реактивная мощность: " << allBus.getReactivePowerGen() << " МВт";
    cout << endl << "Получившаяся стоимость: " << allBus.cost();
    cout << endl << "Проверка по ограничениям: " << allBus.checkRestractions();

    cout << endl << "Мощность в линиях: активная: " << lines.getActivePower()
            << " реактивная: " << lines.getReactivePower();

    cout << endl << "Время расчёта: " << (double)(t2 - t1) / CLOCKS_PER_SEC << " c";
    cout << endl;
}

void Energy::parseData()
{
    parseBusData();
    parseLinesData();
    parseGAparams();
}


void Energy::parseBusData()
{
    TiXmlDocument busDataFile(inputDir + "bus_data.xml");
    busDataFile.LoadFile();
    TiXmlElement * busElements = busDataFile.FirstChildElement("bus-data")->FirstChildElement("buses");
    TiXmlElement * busElement = busElements->FirstChildElement("bus");

    do
    {
        int no = atoi(busElement->FirstChildElement("no")->GetText());
        int code = atoi(busElement->FirstChildElement("code")->GetText());

        EnergyBus * bus = new EnergyBus(no, code);

        bus->setVoltage(
            atof(busElement->FirstChildElement("voltage")->FirstChildElement("value")->GetText()),
            atof(busElement->FirstChildElement("voltage")->FirstChildElement("min-value")->GetText()),
            atof(busElement->FirstChildElement("voltage")->FirstChildElement("max-value")->GetText())
        )->setAngle(
            atof(busElement->FirstChildElement("angle")->FirstChildElement("value")->GetText()),
            atof(busElement->FirstChildElement("angle")->FirstChildElement("min-value")->GetText()) * PI/180,
            atof(busElement->FirstChildElement("angle")->FirstChildElement("max-value")->GetText()) * PI/180
        )->setActivePowerLoad(
            atof(busElement->FirstChildElement("power-load")->FirstChildElement("active")->FirstChildElement("value")->GetText())
        )->setReactivePowerLoad(
            atof(busElement->FirstChildElement("power-load")->FirstChildElement("reactive")->FirstChildElement("value")->GetText())
        );

        if (bus->isGeneratorBus())
        {
            bus->setActivePowerGen(
                atof(busElement->FirstChildElement("power-gen")->FirstChildElement("active")->FirstChildElement("value")->GetText())
            )->setReactivePowerGen(
                atof(busElement->FirstChildElement("power-gen")->FirstChildElement("reactive")->FirstChildElement("value")->GetText())
            )->setPowerGenLimits(
                atof(busElement->FirstChildElement("power-gen")->FirstChildElement("active")->FirstChildElement("min-value")->GetText()),
                atof(busElement->FirstChildElement("power-gen")->FirstChildElement("active")->FirstChildElement("max-value")->GetText()),
                atof(busElement->FirstChildElement("power-gen")->FirstChildElement("reactive")->FirstChildElement("min-value")->GetText()),
                atof(busElement->FirstChildElement("power-gen")->FirstChildElement("reactive")->FirstChildElement("max-value")->GetText())
            );

            TiXmlElement * costPartElement = busElement->FirstChildElement("cost")->FirstChildElement("part");
            do
            {
                bus->setCostPart(
                    atof(costPartElement->FirstChildElement("power")->FirstChildElement("min-value")->GetText()),
                    atof(costPartElement->FirstChildElement("power")->FirstChildElement("max-value")->GetText()),
                    atof(costPartElement->FirstChildElement("coefs")->FirstChildElement("A")->GetText()),
                    atof(costPartElement->FirstChildElement("coefs")->FirstChildElement("B")->GetText()),
                    atof(costPartElement->FirstChildElement("coefs")->FirstChildElement("C")->GetText())
                );
                costPartElement = costPartElement->NextSiblingElement("part");
            }
            while (costPartElement);
            genBus.addBus(bus);
            if ( ! bus->isBalancedBus())
            {
                genWithoutBalanceBus.addBus(bus);
            }
        }
        else
        {
            notGenBus.addBus(bus);
        }

        if (bus->isBalancedBus())
        {
            balanceBus = bus;
        }

        allBus.addBus(bus);
        busElement = busElement->NextSiblingElement("bus");
    }
    while (busElement);
}


void Energy::parseLinesData()
{
    TiXmlDocument lineDataFile(inputDir + "lines_data.xml");
    lineDataFile.LoadFile();
    TiXmlElement * linesElement = lineDataFile.FirstChildElement("lines-data")
                                            ->FirstChildElement("lines");
    TiXmlElement * lineElement = linesElement->FirstChildElement("line");

    do
    {
        int from = atoi(lineElement->FirstChildElement("bus-from")->GetText());
        int to   = atoi(lineElement->FirstChildElement("bus-to")->GetText());

        EnergyBus * busFrom = allBus.getBus(from);
        EnergyBus * busTo = allBus.getBus(to);

        double R = atof(lineElement->FirstChildElement("resistance")->FirstChildElement("active")->GetText());
        double X = atof(lineElement->FirstChildElement("resistance")->FirstChildElement("reactive")->GetText());

        EnergyLine * line = new EnergyLine(busFrom, busTo, R, X);
        lines.addLine(line);
        lineElement = lineElement->NextSiblingElement("line");
    }
    while (lineElement);
}


void Energy::parseGAparams()
{
    GASteadyStateGA::registerDefaultParameters(params);
    TiXmlDocument gaParamsFile(inputDir + "ga_params.xml");
    gaParamsFile.LoadFile();
    TiXmlElement * gaParamsElement = gaParamsFile.FirstChildElement("ga-params");
    string scoreFilename = outputDir + gaParamsElement->FirstChildElement("score-filename")->GetText();

    params.set(gaNnGenerations,   atoi(gaParamsElement->FirstChildElement("number-of-generation")->GetText()));
    params.set(gaNpopulationSize, atoi(gaParamsElement->FirstChildElement("population-size")->GetText()));
    params.set(gaNpMutation,      atof(gaParamsElement->FirstChildElement("mutation-probability")->GetText()));
    params.set(gaNpCrossover,     atof(gaParamsElement->FirstChildElement("crossover-probability")->GetText()));

    params.set(gaNscoreFrequency, atoi(gaParamsElement->FirstChildElement("score-frequency")->GetText()));
    params.set(gaNflushFrequency, atoi(gaParamsElement->FirstChildElement("score-flush-frequency")->GetText()));
    params.set(gaNselectScores,   (int)GAStatistics::AllScores);
    params.set(gaNscoreFilename,  scoreFilename.c_str());
}


float Energy::wrap_objective(GAGenome & g)
{
    return Energy::getInstance()->objective(g);
}


double Energy::wrap_getYCell(int i, int j, vector <double> x)
{
    return Energy::getInstance()->getYCell(i, j, x);
}


double Energy::wrap_getFCell(int i, vector <double> x)
{
    return Energy::getInstance()->getFCell(i, x);
}


void Energy::report()
{
    TiXmlDocument reportFile(outputDir + "report.xml");
    TiXmlDeclaration * decl = new TiXmlDeclaration("1.0", "utf-8", "");
    TiXmlElement * report = new TiXmlElement("report");

    TiXmlDocument busDataFile(inputDir + "bus_data.xml");
    busDataFile.LoadFile();
    TiXmlNode * busElements = busDataFile.FirstChildElement("bus-data")
            ->FirstChildElement("buses")->Clone();

    TiXmlDocument lineDataFile(inputDir + "lines_data.xml");
    lineDataFile.LoadFile();
    TiXmlNode * lineElements = lineDataFile.FirstChildElement("lines-data")
            ->FirstChildElement("lines")->Clone();

    TiXmlElement * solve = new TiXmlElement("solve");

    reportFile.LinkEndChild(decl);
    reportFile.LinkEndChild(report);
    report->LinkEndChild(busElements);
    report->LinkEndChild(lineElements);
    report->LinkEndChild(solve);

    TiXmlElement * busElement = busElements->FirstChildElement("bus");
    do
    {
        int no = atoi(busElement->FirstChildElement("no")->GetText());
        EnergyBus * bus = allBus.getBus(no);

        char str[20];
        sprintf(str, "%f", bus->getVoltage());
        busElement->FirstChildElement("voltage")->FirstChildElement("value")->Clear();
        busElement->FirstChildElement("voltage")->FirstChildElement("value")
                ->LinkEndChild(new TiXmlText(str));

        sprintf(str, "%f", bus->getAngle());
        busElement->FirstChildElement("angle")->FirstChildElement("value")->Clear();
        busElement->FirstChildElement("angle")->FirstChildElement("value")
                ->LinkEndChild(new TiXmlText(str));

        if (bus->isGeneratorBus())
        {
            sprintf(str, "%f", bus->getActivePowerGen());
            busElement->FirstChildElement("power-gen")->FirstChildElement("active")
                    ->FirstChildElement("value")->Clear();
            busElement->FirstChildElement("power-gen")->FirstChildElement("active")
                ->FirstChildElement("value")->LinkEndChild(new TiXmlText(str));

            sprintf(str, "%f", bus->getReactivePowerGen());
            busElement->FirstChildElement("power-gen")->FirstChildElement("reactive")
                    ->FirstChildElement("value")->Clear();
            busElement->FirstChildElement("power-gen")->FirstChildElement("reactive")
                ->FirstChildElement("value")->LinkEndChild(new TiXmlText(str));

            sprintf(str, "%f", bus->cost());
            busElement->FirstChildElement("cost")->LinkEndChild(new TiXmlElement("total"))
                    ->LinkEndChild(new TiXmlText(str));
        }

        sprintf(str, "%f", bus->getG());
        busElement->LinkEndChild(new TiXmlElement("G"))
                ->LinkEndChild(new TiXmlText(str));

        sprintf(str, "%f", bus->getB());
        busElement->LinkEndChild(new TiXmlElement("B"))
                ->LinkEndChild(new TiXmlText(str));

        busElement = busElement->NextSiblingElement("bus");
    }
    while (busElement);

    TiXmlElement * lineElement = lineElements->FirstChildElement("line");
    do
    {
        int from = atoi(lineElement->FirstChildElement("bus-from")->GetText());
        int to = atoi(lineElement->FirstChildElement("bus-to")->GetText());
        EnergyLine * line = lines.getLine(from, to);

        char str[20];
        sprintf(str, "%f", line->getG());
        lineElement->LinkEndChild(new TiXmlElement("G"))
                ->LinkEndChild(new TiXmlText(str));

        sprintf(str, "%f", line->getB());
        lineElement->LinkEndChild(new TiXmlElement("B"))
                ->LinkEndChild(new TiXmlText(str));

        lineElement = lineElement->NextSiblingElement("line");
    }
    while (lineElement);


    reportFile.SaveFile();
}

void Energy::progress(float percent)
{
    static string bars = "Считаем ";

    if (bars.length() - 13 < percent)
    {
        bars += "|";
    }

    cout << bars << " " << percent << " %\r";
    fflush(stdout);
}
/* File src/EnergyLine.cpp */

#include "EnergyLine.h"

using namespace std;

EnergyLine::EnergyLine(EnergyBus * fromBus, EnergyBus * toBus, double r, double x)
{
    from = fromBus;
    to   = toBus;
    R = r;
    X = x;
    G = R / (X * X + R * R);
    B = X / (X * X + R * R);
}

double EnergyLine::getR()
{
    return R;
}

double EnergyLine::getX()
{
    return X;
}

double EnergyLine::getG()
{
    return G;
}

double EnergyLine::getB()
{
    return B;
}

double EnergyLine::getActivePower()
{

    double Vk = from->getVoltage();
    double Vm = to->getVoltage();
    double Dk = from->getAngle();
    double Dm = to->getAngle();
    double Gkm = getG();

    // @todo 100 вынести в констатну везде
    return 100 * Gkm * (Vk * Vk + Vm * Vm - 2 * Vk * Vm * cos(Dk - Dm));
}

double EnergyLine::getReactivePower()
{

//    double Vk = from->getVoltage();
//    double Vm = to->getVoltage();
//    double Dk = from->getAngle();
//    double Dm = to->getAngle();
//    double Bkm = getB();

//    @todo подумать
//    return 100 * Bkm * (Vk * Vk + Vm * Vm + 2 * Vk * Vm * cos(Dk - Dm));
    return 0;
}

EnergyBus * EnergyLine::getFrom()
{
    return from;
}

EnergyBus * EnergyLine::getTo()
{
    return to;
}

void EnergyLine::display()
{
    cout << endl << "*** Линия из " << from->getNo() << " в " << to->getNo() << " *** "
            << "G=" << getG() << "; B=" << getB() << "; R=" << R << "; X=" << X
            << "; P=" << getActivePower() << "; Q=" << getReactivePower();
}
/* File src/EnergyLineSet.cpp */

#include "EnergyLineSet.h"

EnergyLineSet::EnergyLineSet()
{

}

EnergyLineSet * EnergyLineSet::addLine(EnergyLine * line)
{
    // @todo правильно составить ключ
    int key = line->getFrom()->getNo() * 1000 + line->getTo()->getNo();
    lines[key] = line;
    //@todo
    links[line->getFrom()->getNo()].push_back(line);
    links[line->getTo()->getNo()].push_back(line);
    line->getFrom()->addLinkedBus(line->getTo(), line->getG(), line->getB());
    line->getTo()->addLinkedBus(line->getFrom(), line->getG(), line->getB());
    return this;
}

EnergyLine * EnergyLineSet::getLine(int from, int to)
{
    int key = from * 1000 + to;
    if (lines.count(key) < 1)
    {
        key = to * 1000 + from;
    }
    // @todo узкое место, нужна проверка на map::end()
    return lines.find(key)->second;
}

int EnergyLineSet::size()
{
    return lines.size();
}

double EnergyLineSet::getActivePower()
{
    double ret = 0.0;

    for (it = lines.begin(); it != lines.end(); ++it)
    {
        ret += it->second->getActivePower();
    }

    return ret;
}

double EnergyLineSet::getReactivePower()
{
    double ret = 0.0;

    for (it = lines.begin(); it != lines.end(); ++it)
    {
        ret += it->second->getReactivePower();
    }

    return ret;
}

vector <EnergyLine*> EnergyLineSet::getBusLines(int busNo)
{
    return links[busNo];
}

EnergyLine* EnergyLineSet::operator [](int n)
{
    it = lines.begin();
    // @todo
    for (int i = 0; i < n; ++i, ++it);
    return it->second;
}
/* File src/Gauss.cpp */

#include "Gauss.h"

using namespace std;

template<typename T> T abs(T x) { return x < 0 ? -x : x; }

const double EPS = 1e-9;

int gauss(vector < vector<double> > a, vector <double> b, vector <double> &ans)
{
    int n = (int) a.size();
    int m = (int) a[0].size();

    for (int i = 0; i < n; ++i)
    {
        a[i].push_back(b[i]);
    }

    vector<int> where (m, -1);
    for (int col=0, row=0; col<m && row<n; ++col)
    {
        int sel = row;
        for (int i=row; i<n; ++i)
            if (abs (a[i][col]) > abs (a[sel][col]))
                sel = i;
        if (abs (a[sel][col]) < EPS)
            continue;
        for (int i=col; i<=m; ++i)
            swap (a[sel][i], a[row][i]);
        where[col] = row;

        for (int i=0; i<n; ++i)
            if (i != row) {
                double c = a[i][col] / a[row][col];

                for (int j=col; j <= m; ++j)
                    a[i][j] -= a[row][j] * c;
            }
        ++row;
    }

    ans.assign (m, 0);
    for (int i=0; i<m; ++i)
        if (where[i] != -1)
            ans[i] = a[where[i]][m] / a[where[i]][i];
    for (int i=0; i<n; ++i)
    {
        double sum = 0;

        for (int j=0; j<m; ++j)
            sum += ans[j] * a[i][j];
        if (abs (sum - a[i][m]) > EPS)
            return 0;
    }

    for (int i=0; i<m; ++i)
        if (where[i] == -1)
            return -1;

    return 1;
}
/* File src/main.cpp */

#include <string>
#include "Energy.h"

using namespace std;

int main(int argc, char** argv)
{
    // Вытаскиваем из параметров нужные
    char *s = NULL;
    int c;

    opterr = 0;

    while ((c = getopt (argc, argv, "s:")) != -1)
    {
        switch (c)
        {
            case 's':
              s = optarg;
              break;
            case '?':
              if (optopt == 's')
                fprintf(stderr, "Option -%c requires an argument.\n", optopt);
              else if (isprint(optopt))
                fprintf(stderr, "Unknown option `-%c'.\n", optopt);
              else
                fprintf(
                            stderr,
                            "Unknown option character `\\x%x'.\n",
                            optopt
                        );
              return 1;
            default:
              abort();
        }
    }

    string inputDir = "input/set_";
    string outputDir = "output/set_";
    if (s)
    {
        inputDir += s;
        inputDir += "/";
        outputDir += s;
        outputDir += "/";
    }
    else
    {
        inputDir += "default/";
        outputDir += "default/";
    }

    Energy * energy = Energy::getInstance();
    energy->setup(inputDir, outputDir);
    energy->solve();

    return 0;
}
/* File src/Newton.cpp */

#include <iostream>
#include "Newton.h"

template<typename T> T abs(T x) { return x < 0 ? -x : x; }

Newton::Newton(
        double (*fCell)(int, vector <double>),
        double (*yCell)(int, int, vector <double>),
        double eps,
        int max,
        bool debug
    )
{
    getFCell = fCell;
    getYCell = yCell;
    EPS = eps;
    MAX_STEPS = max;
    DEBUG = debug;
}

int Newton::solve(vector <double> &x)
{
    X = x;
    N = X.size();

    bool check = true;
    int ret = 0;
    int step = 0;

    while(check)
    {
        // @todo убрать присваивание
        F = getF();
        Y = getY();

        if ((ret = gauss(Y, F, Z)) != 1)
        {
            check = false;
        }

        if (DEBUG)
        {
            std::cout << endl << "************" << endl << "Шаг №" << step;
            std::cout << endl << "Y:";
            for (int j = 0; j < N; ++j)
            {
              std::cout << endl << j << ": ";
              for (int k = 0; k < N; ++k)
              {
                  std::cout << Y[j][k] << " ";
              }
            }
            std::cout << endl << "F:";
            for (int j = 0; j < N; ++j)
            {
              std::cout << endl << j << ": " << F[j];
            }
            std::cout << endl << "Решение:" << ret << endl;
            for (int j = 0; j < N; ++j)
            {
              std::cout << "x" << j << " = " << X[j] << "; ";
            }
            std::cout << endl << "Решение линейной системы: " << endl;
            for (int j = 0; j < N; ++j)
            {
              std::cout << "z" << j << " = " << Z[j] << "; ";
            }
            std::cout << endl << "Погрешность: " << getEPS();
            std::cout << endl << "************" << endl;
        }

        if (getEPS() < EPS)
        {
            check = false;
            ret = 1;
        }
        else if (++step > MAX_STEPS)
        {
            check = false;
            ret = 0;
        }
        else
        {
            for (int j = 0; j < N; ++j)
            {
                X[j] -= Z[j];
            }
        }
    }

    x = X;
    return ret;
}


vector <double> Newton::getF()
{
    vector <double> ret;

    for (int i = 0; i < N; ++i)
    {
        ret.push_back((*getFCell)(i, X));
    }

    return ret;
}

vector < vector <double> > Newton::getY()
{
    vector < vector <double> > ret;

    for (int i = 0; i < N; ++i)
    {
        vector <double> row;

        for (int j = 0; j < N; ++j)
        {
            row.push_back((*getYCell)(i, j, X));
        }
        ret.push_back(row);
    }

    return ret;
}

double Newton::getEPS()
{
    double ret = abs(Z[0]);

    // @todo iterator
    for (int i = 1; i < N; ++i)
    {
        if (abs(Z[i]) > ret)
        {
            ret = abs(Z[i]);
        }
    }

    return ret;
}
